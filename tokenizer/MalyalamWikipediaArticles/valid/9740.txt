ഐക്കൺ വളരെ ഉയർന്ന നിലവാരമുള്ള പ്രോഗ്രാമിങ് ഭാഷയാണ്,ഗണിത നിർദ്ദേശങ്ങളുള്ള നിർവ്വഹണ രീതികളും, പാഠഭാഗങ്ങളും മാനദണ്ഡങ്ങൾ കൈകാര്യം ചെയ്യുന്നതിനുള്ള സൗകര്യവും ഉൾപ്പെടുത്തിയിട്ടുണ്ട്. ഇത് സ്ട്രിംഗ് പ്രോസ്സസിംഗ് ഭാഷകൾക്കുള്ള SNOBOL, SL5 എന്നിവയുമായി ബന്ധപ്പെട്ടിരിക്കുന്നു. ഐക്കൺ ഒബ്ജക്റ്റ് ഓറിയെൻറഡ് അല്ല, എന്നാൽ ഐഡോൾ എന്ന ഒരു ഒബ്ജക്റ്റ് ഓറിയെൻറഡ് എക്സ്റ്റൻഷൻ 1996 ൽ ആണ് വികസിപ്പിച്ചത്. പിന്നീട് യൂണികോണായി മാറി.
ഘടനാപരമായ പ്രോഗ്രാമിങ് ഭാഷകളുടെ ആൽഗോൾ ക്ലാസ്സിൽ നിന്നും ഐക്കൺ ഭാഷ വേർതിരിക്കപ്പെട്ടിരിക്കുന്നു, സി അല്ലെങ്കിൽ പാസ്കൽ പോലെയുള്ള വാക്യഘടന ഉണ്ട്.ഐക്കൺ പാസ്കലിനോട് ഏറ്റവും അടുത്ത സാദൃശ്യമുണ്ട്, := സിൻറാക്സ്, അസൈൻമെൻറുകൾ, നടപടിക്രമം കീവേഡ്, സമാന സിൻറാക്സ്. മറുവശത്ത്, എക്സിക്യൂഷൻ ഗ്രൂപ്പുകൾ നിർമ്മിക്കുന്നതിനായി സി ശൈലിയിലുള്ള ബ്രാക്കറ്റുകൾ ഐക്കൺ ഉപയോഗിക്കുന്നു, ഒപ്പം പ്രോഗ്രാമുകൾ "മെയിൻ" പ്രോസസ് നടത്തുന്നതിലൂടെ ആരംഭിക്കുകയും ചെയ്യുന്നു. മിക്ക രീതികളിലും ഐക്കണാണ് മിക്ക സ്ക്രിപ്റ്റിംഗ് ഭാഷകളുമായി ഫീച്ചറുകൾ പങ്കുവയ്ക്കുന്നത് : വേരിയബിളുകൾ പ്രഖ്യാപിക്കപ്പെടേണ്ടതില്ല, ടൈപ്പുകളെ സ്വപ്രേരിതമായി കാസ്റ്റുചെയ്യും, കൂടാതെ നമ്പറുകൾ സ്ട്രിങ്ങുകളായി മാറ്റുകയും സ്വപ്രേരിതമായി മടങ്ങുകയും ചെയ്യും. 
പ്രോസീജെഴ്സ് ആണ് ഐക്കൺ പ്രോഗ്രാമുകളുടെ അടിസ്ഥാന നിർമ്മാണ ബ്ലോക്കുകൾ. അവർ പാസ്കൽ നാമധേയം ഉപയോഗിച്ചുവെങ്കിലും, സി പ്രവർത്തനങ്ങൾ പോലെ പ്രവർത്തിക്കുകയും മൂല്യങ്ങൾ മടക്കിനൽകുകയും ചെയ്യുന്നു; ഇവിടെ ഐക്കണിൽ function കീവേഡ് ഇല്ല.
ഐക്കണുകളുടെ പ്രധാന ആശയങ്ങളിൽ ഒന്നാണ്, മറ്റ് മിക്ക പ്രോഗ്രാമിംഗ് ഭാഷകളിലും ഉള്ള, നിയന്ത്രണ ഘടകങ്ങൾ "വിജയിക്കുക" അല്ലെങ്കിൽ "പരാജയപ്പെടുക" എന്ന ബൂളിയൻ യുക്തിയിൽ അധിഷ്ഠിതമാണ്.ഈ മാതൃക പ്രകാരം, ലളിതമായ താരതമ്യങ്ങൾ a < b എന്ന കോഡ് മിക്ക ഭാഷകളുടെയും പോലെ "വലതു വശത്തുള്ള പ്രവർത്തനങ്ങൾ ശരിയെന്നു വിലയിരുത്തുക" എന്നല്ല അർത്ഥമാക്കുന്നത്; പകരം ഇത് കൂടുതൽ അർത്ഥമാക്കുന്നത് "ശരിയായ പ്രവർത്തനങ്ങൾ വിജയിക്കുകയാണെങ്കിൽ" എന്നതാണ്. ഈ സാഹചര്യത്തിൽ, താരതമ്യം ചെയ്യൽ ശരിയാണെങ്കിൽ < ഓപ്പറേറ്റർ വിജയിക്കുന്നു, അതിനാൽ അവസാന ഫലം ഒരുപോലെയാണ്. ഇതുകൂടാതെ, < ഓപ്പറേറ്റർ അതിൻറെ രണ്ടാമത്തെ ആർഗ്യുമെൻറ് നൽകുന്നു, അത് വിജയിക്കുകയാണെങ്കിൽ, അതുപോലുള്ള കാര്യങ്ങൾ അനുവദിക്കുന്നു if a < b < c, മിക്കവാറും ഭാഷകളിൽ സാധാരണമായ ഒരു താരതമ്യം രണ്ട് ഇൻഇക്വാളിറ്റിയുടെ സംയോജനമായി എഴുതണം if a < b && b < c.
ലളിതമായ ഈ കോഡ് എല്ലാ ഫ്ലോ നിയന്ത്രണങ്ങളും ഐക്കണിൽ വിജയിക്കുന്നതോ അല്ലെങ്കിൽ പരാജയപ്പെടുന്നതോ ആയതിനാൽ, നിങ്ങൾക്ക് നിഗൂഢമായ ഉദാഹരണങ്ങൾ പരിഗണിക്കുമ്പോൾ ഈ ആശയത്തിൻറെ പ്രയോഗം കൂടുതൽ വ്യക്തമാകും:
റീഡ് കമാൻഡ് പരാജയപ്പെടുമ്പോൾ, ഉദാഹരണത്തിന് ഫയൽ അവസാനിക്കുമ്പോൾ, ഈ ചെയിനിൽ പരാജയപ്പെടൽ കൈമാറും, റൈറ്റ് കമാൻഡ് അതുപോലെ തന്നെ പരാജയപ്പെടും. ഒരു കൺട്രോൾ ഘടന എന്ന നിലയിൽ, പരാജയത്തിൽ നിർത്തുന്നു, ഫയൽ ശൂന്യമാക്കുമ്പോൾ ഇത് നിർത്തലാക്കും എന്നർത്ഥം. താരതമ്യത്തിനായി, സമാനമായ ഒരു ഉദാഹരണം പരിഗണിക്കുക സ്യൂഡോകോഡിൽ ആണ് :
ഈ കേസിൽ രണ്ട് താരതമ്യങ്ങൾ ആവശ്യമാണ്: ഒന്നാമത്തേത് ഫയലിൻറെ അവസാനം, മറ്റ് പിശകുകൾ എന്നിവയ്ക്ക് മറ്റൊന്ന്. ജാവ പിശകുകൾ അനുവദിക്കാത്തതിനാൽ, ലോജിക്കൽ ഘടകങ്ങളായി, ഐക്കണിൻറെ കീഴിൽ ഇതിനെ താരതമ്യം ചെയ്യാം, പകരം നീളമുള്ളtry/catch സിൻറാക്സ് ഉപയോഗിയ്ക്കണം. ബ്ളോക്കുകൾ ഉപയോഗിക്കുമ്പോൾ പെർഫോമൻസ് ഉപയോഗിക്കുന്നത് കൂടാതെ, ഒരു പിശക് സംഭവിക്കുന്നില്ലെങ്കിൽ പോലും, ഐക്കൺ ഒഴിവാക്കുന്ന ഒന്നാണ് ഡിസ്റ്റിബ്യൂട്ടെഡ് കോസ്റ്റ്.
ലക്ഷ്യം നടപ്പാക്കൽ പോലെ, ഐക്കൺ ഈ ആശയത്തെ സൂചിപ്പിക്കുന്നു, ചില ലക്ഷ്യങ്ങളിൽ എത്തുന്നതുവരെ ഈ നടപ്പാക്കൽ തുടർന്നു. മുകളിലുള്ള ഉദാഹരണത്തിൽ ലക്ഷ്യം പൂർത്തീകരിക്കുന്നത് വരെ മുഴുവൻ ഫയലും വായിക്കണം; റീഡ് കമാൻഡ് വിജയിക്കുന്നതുവരെ തുടരുന്നു, കൂടുതൽ വിവരങ്ങൾ വായിക്കപ്പെടെണ്ടതാണ്, അവിടെ ഇൻഫോർമേഷൻ ഇല്ലാത്തപ്പോൾ പരാജയപ്പെടുന്നു. അങ്ങനെ ലക്ഷ്യം നടപ്പിലാക്കുന്നതിന് റിട്ടേൺ കോഡുകൾ അല്ലെങ്കിൽ സമാനമായ നിർമ്മിതികൾ പരിശോധിച്ച് നിർദ്ദേശങ്ങൾ ഉപയോഗിക്കുന്നതിനു പകരമാണ്, ഭാഷയെ നേരിട്ട് കോഡ് ചെയ്തിരിക്കുന്നത്.
ഉദാഹരണത്തിന്, ഐക്കണിലെ എക്സ്പ്രഷനുകൾ പലപ്പോഴും ഒരൊറ്റ മൂല്യം നൽകുന്നു,x < 5 ൻറെ മൂല്യം 5 ൽ കുറവാണെങ്കിൽ അല്ലെങ്കിൽ പരാജയപ്പെടുകയാണെങ്കിൽx < 5വിലയിരുത്തുകയും വിജയിക്കുകയും ചെയ്യും. എന്നിരുന്നാലും താഴെ പറയുന്ന ഉദാഹരണങ്ങളിൽ അനേകം എക്സ്പ്രഷനുകൾ വിജയിക്കുകയോ പരാജയപ്പെടുകയോ ചെയ്യുന്നില്ല എന്ന വസ്തുതയിൽ ആശ്രയിച്ച്, അതേ സമയം തന്നെ മൂല്യങ്ങൾ തിരികെ നൽകുന്നു. ഇത് എല്ലാത്തിനും മാതൃകകളിലേക്ക് നയിക്കുന്നു; മൂല്യങ്ങൾ തുടർന്നും പരാജയപ്പെടുവോളം എല്ലാ കാരണങ്ങളും തുടരുന്നു.
ഇത് ജനറേറ്ററായി അറിയപ്പെടുന്ന ഐക്കണിലെ ഒരു പ്രധാന ആശയമാണ്. ജനറേറ്ററുകൾ അധികമായി ഭാഷയിലുള്ള ലൂപ്പ് പ്രവർത്തനം ഡ്രൈവ് ചെയ്യുന്നു, പക്ഷെ കൂടുതൽ നേരിട്ട് ചെയ്യുന്നു; പ്രോഗ്രാമർ ഒരു ലൂപ്പ് എഴുതുന്നില്ല, തുടർന്ന് മൂല്യങ്ങൾ പിൻവലിച്ച് താരതമ്യം ചെയ്യുന്നു, ഐക്കൺ എല്ലാം നിങ്ങൾക്കായി ചെയ്യും.
ഐക്കണിൻറെ പ്രതീകത്തിനുള്ളിൽ, ഫലത്തിൻറ‌െ ശ്രേണിയിൽ ഒരു പദപ്രയോഗം അല്ലെങ്കിൽ പ്രവർത്തനത്തിൻറെ വിലയിരുത്തൽ നടത്തുന്നു. എക്സ്പ്രഷൻ അല്ലെങ്കിൽ ഫങ്ഷൻ ഉപയോഗിച്ച് സൃഷ്ടിക്കാൻ സാധ്യമായ എല്ലാ മൂല്യങ്ങളും ഒരു സീക്വൻസിനുണ്ട്. ഫലത്തിൻറെ സീക്വൻസ് തീർന്നിരിക്കുമ്പോൾ, എക്സ്പ്രഷൻ അല്ലെങ്കിൽ പ്രവർത്തനം പരാജയപ്പെടുന്നു. ഐക്കണിൻറെ ലക്ഷ്യം മൂല്യനിർണ്ണയം അല്ലെങ്കിൽ വ്യക്തമായും ഓരോ ഭാഗവും വഴി ഐക്കണിലെ ലക്ഷ്യം നേടുക വഴി റിസൾട്ട് ലഭിക്കുന്നതാണ്.
ഐക്കണിൽ നിരവധി ജനറേറ്റർ-നിർമ്മാതാക്കൾ ഉൾപ്പെടുന്നു. എതെങ്കിലും ഒന്ന് പരാജയപ്പെടുന്നതുവരെ ആൾട്ടർനേറ്റീവ് സിൻറാക്സ് ഒരു ശ്രേണിയിൽ ഇനങ്ങൾ സൃഷ്ടിക്കാൻ അനുവദിക്കുന്നു:
"1", "ഹലോ", "5" എന്നിവ x 5 ന് താഴെയാണെങ്കിൽ റിസൾട്ട് സ‌ൃഷ്ടിക്കാൻ കഴിയും. ആൾട്ടർനേറ്റർമാർ മിക്കപ്പോഴും "അല്ലെങ്കിൽ" എന്ന രീതിയിൽ വായിക്കാൻ കഴിയും, ഉദാഹരണത്തിന്:
x അല്ലെങ്കിൽ 5-നേക്കാൾ ചെറുതാണെങ്കിൽ y യുടെ മൂല്യം എഴുതുന്നു. ഓരോ മൂല്യവും ഇടത്തുനിന്ന് വലത്തേക്ക് ആന്തരികമായി ഐക്കൺ പരിശോധിക്കുന്നു ഒരു വിജയം നേടുന്നതു വരെ അല്ലെങ്കിൽ ലിസ്റ്റ് എംമ്പ്റ്റി ആകുന്നതു വരെ. മാത്രമല്ല അത് പരാജയപ്പെടുന്നു. അകത്തുളള കോളുകൾ പരാജയപ്പെടാത്ത പക്ഷം ഫംഗ്ഷനുകൾ വിളിക്കില്ല എന്ന് ഓർത്തുവെയ്ക്കുക, അങ്ങനെ ഈ ഉദാഹരണം ചുരുക്കാൻ കഴിയും:
മറ്റൊരു ലളിതമായ ജനറേറ്റർ, ആണ് to എന്നത്, ഇത് പൂർണ്ണസംഖ്യകളുടെ പട്ടിക ഉണ്ടാക്കുന്നു; every write ഈ കോഡിൽ കാണുന്നതെന്താണോ അത് കൃത്യതയോടെ ചെയ്യും. ബാംഗ് സിൻറാക്സ് ഒരു ലിസ്റ്റിലെ എല്ലാ ഇനങ്ങളും സൃഷ്ടിക്കുന്നു; every write എസ്ട്രിങിൻറെ ഓരോ ക്യാരക്റ്ററും ഒരു പുതിയ വരിയിൽ ഔട്ട്പുട്ട് ചെയ്യും.
ഈ ആശയത്തിൻറെ ശക്തി തെളിയിക്കുന്നതിനായി, സ്ട്രിംഗ് പ്രവർത്തനങ്ങൾ പരിഗണിക്കുന്നു. മിക്ക ഭാഷകളിലും find അല്ലെങ്കിൽ indexOf എന്നറിയപ്പെടുന്ന ഒരു ഫംഗ്ഷൻ മറ്റൊരു സ്ട്രിംഗ് ലൊക്കേഷനിൽ മറ്റൊരു സ്ഥാനം നൽകുന്നു. പരിഗണിക്കുക:
ഈ കോഡ് "the" എന്ന വാക്കിൻറെ ആദ്യ സംഭവത്തിൻറെ 4-ാം സ്ഥാനത്ത് വരും. "The" എന്ന മറ്റൊരു ഉദാഹരണത്തിൽ ഒരു ഇതര ഫോം ഉപയോഗിക്കണം,
അഞ്ചാമത്തെ സ്ഥാനത്ത് നിന്ന് നോക്കണം എന്ന് 5 ൻറെ അവസാനം പറയുന്നു. "The" യുടെ എല്ലാ സന്ദർഭങ്ങളും എക്സ്ട്രാക്റ്റു ചെയ്യുന്നതിന്, ഒരു ലൂപ്പ് ഉപയോഗിക്കണം ...
ഐക്കണിനു കീഴിൽ find എന്ന പ്രവർത്തനം ഒരു ജനറേറ്ററാണ്, ഓരോ സമയത്തും സ്ട്രിങ്ങിൻറെ അടുത്ത ഇൻസ്റ്റൻസ് തിരികെയെത്തുകയും, അത് സ്ട്രിംഗിൻറെ അവസാനം കടന്നു കഴിഞ്ഞാൽ, അവസാനം പരാജയപ്പെടുന്നതിനുമുമ്പ് അത് പുനരാരംഭിക്കും. ഐക്കണിൻറെ അതേ കോഡ് എഴുതാം:
"the" എന്ന സ്ഥാനത്ത് 5 ആണെങ്കിൽ, സ്ഥാനം മാത്രം തിരികെ നൽകും, താരതമ്യപ്പെടുത്തൽ പരാജയപ്പെടുകയാണെങ്കിൽ, write കോഡ് മുമ്പ് പാസ് ചെയ്യാൻ കഴിയാത്തതിനാൽ പരാജയപ്പെട്ടു. പരിഗണിക്കപ്പെടേണ്ട ഈ കോഡിന് ഒരു ചെറിയ "ട്രിക്ക്" ഉണ്ട്: താരതമ്യങ്ങൾ വലതു കൈ ഫലങ്ങൾ നൽകുന്നു, അതിനാൽ താരതമ്യത്തിൻറെ വലതുവശത്തെ കണ്ടെത്തൽ പ്രധാനമാണ്. 5 വലത് ഭാഗത്ത് വയ്ക്കുകയാണെ ങ്കിൽ, 5 എഴുതപ്പെടും. ജനറേറ്ററുകൾ വഴി ലൂപ്പുചെയ്യുന്നതി നായി ഐക്കൺ നിരവധി നിയന്ത്രണ സംവിധാനങ്ങൾ ചേർക്കുന്നു. ഓരോ every ഓപ്പറേറ്റർക്കും സമാനമായ സമയത്ത് while, ഒരു ജനറേറ്ററിനാൽ തിരിച്ചുകിട്ടുന്ന എല്ലാ ഇനങ്ങളിലൂടെയും വീണ്ടും ലൂപ്പിംഗ് ചെയ്ത് പരാജയത്തിൽ കലാശിക്കുന്നു:
ഈ കേസിൽ വൈയിൽ ലൂപ്ന് പകരം everyഎന്ന കോഡ് എന്തുകൊണ്ട് ഉപയോഗിക്കുന്നു? കാരണംwhileആദ്യ ഫലം വിലയിരുത്തുക, എന്നാൽ everyഎല്ലാ ഫലങ്ങളും നൽകുന്നു.every എന്ന കോഡിൽ ഓരോ വാക്യഘടനയും സ്മോൾടോക്കിനു കീഴിലുള്ള ബ്ലോക്കുകൾ പോലെയുള്ള ഒരു ഫങ്ഷനിൽ ഫംങ്ഷനിലേക്ക് മൂല്യം നൽകുന്നു. ഉദാഹരണത്തിന് മുകളിൽ പറഞ്ഞ ലൂപ്പ് ഇങ്ങനെ വീണ്ടും എഴുതാൻ സാധിക്കും:
suspend കീവേഡ് ഉപയോഗിച്ച് ഉപയോക്താവിന് പുതിയ ജനറേറ്ററുകൾ എളുപ്പത്തിൽ നിർമ്മിക്കാൻ കഴിയും:
പാറ്റേൺ കണ്ടെത്തുന്നതിനായി TheString-ൽ ഈ ഉദാഹരണം ശ്രദ്ധിക്കുന്നു. ഒരെണ്ണം കണ്ടെത്തിയപ്പോൾ, അതിൻറെ സ്ഥാനം ഓഡ് ആണ്,suspend എന്ന കോഡിൻറെ സ്ഥാനം ഫങ്ഷനിൽ തിരികെയെത്തുന്നു. അവിടെ ആന്തരിക ജനറേറ്ററിലും, അടുത്ത ഇറേറ്ററിൽ എവിടെയാണോ നിർത്തിയത് അവിടെ നിന്നാണ് അത് പോകാൻ അനുവദിക്കുന്നത്, return, കോഡിൽ നിന്ന് വ്യത്യസ്തമായി, ആന്തരിക ജനറേറ്ററുകളിൽ suspend രേഖപ്പെടുത്തുന്നു, അടുത്ത ആവർത്തനത്തിൽ വിട്ട് കളഞ്ഞത് എവിടെയാണോ അത് എടുക്കാൻ അനുവദിക്കുന്നു.
സ്ക്രിപ്റ്റ് പോലുള്ള പ്രവർത്തനം നിലനിർത്തുന്നതിന്, സ്ട്രിംഗ് ഉപയോഗിച്ച് എളുപ്പത്തിൽ പ്രവർത്തിക്കുന്നതിന് ഐക്കൺ നിരവധി സവിശേഷതകൾ ചേർക്കുന്നു. ഇതിൽ ഏറ്റവും ശ്രദ്ധേയമായത് സ്കാനിംഗ് സിസ്റ്റം ആണ്, അത് ആവർത്തിച്ച് വിളിക്കുന്നത് സ്ട്രിംഗിൽ പ്രവർത്തിക്കുന്നു:
നേരത്തെ കാണിച്ചിരിക്കുന്ന ഉദാഹരണങ്ങളുടെ ഒരു ചെറിയ രൂപമാണിത്. ഈ സന്ദർഭത്തിൽ ചോദ്യ ചിഹ്നത്തിനു മുമ്പിലുള്ള പരാമീറ്ററുകൾക്ക് പുറത്ത് find ഫംഗ്ഷൻറെ വിഷയം സ്ഥാപിക്കുന്നു. ഐക്കൺ പ്രവർത്തനങ്ങൾ മനഃപൂർവ്വം ഈ വിഷയം പാരാമീറ്റർ ലിസ്റ്റുകളിൽ തിരിച്ചറിയുന്നതിനായി എഴുതിയിരിക്കുന്നു, അവ ഈ രീതിയിൽ പിൻവലിക്കാൻ അനുവദിക്കുന്നു.
ബ്രാക്കറ്റിനുള്ളിൽ ഒരു ശ്രേണി സ്പെസിഫിക്കേഷൻ ഉപയോഗിച്ചുകൊണ്ട് ഒരു സ്ട്രിംഗിൽ നിന്ന് ഉപസ്ട്രിംഗുകൾ വേർതിരിച്ചെടുക്കാം. ഒരു റേഞ്ച് സ്പെസിഫിക്കേഷൻ ഒരു പ്രതീകത്തിലേക്ക് ഒരു പോയിൻറ് മടക്കി നൽകാൻ കഴിയും, അല്ലെങ്കിൽ സ്ട്രിംഗിൻറെ ഒരു സ്ലൈസ്. സ്ട്രിംഗുകൾ വലത് അല്ലെങ്കിൽ ഇടത് ഭാഗത്തുനിന്നും ഇൻഡെക്സ് ചെയ്യാവുന്നതാണ്. ഒരു സ്ട്രിംഗിലെ സ്ഥാനങ്ങൾ പ്രതീകങ്ങൾക്കിടയിലായിരിക്കണം നിർവചിച്ചിരിക്കുന്നത്. 1A2B3C4 ഇത് വലത്തു നിന്നും വ്യക്തമാക്കാം −3A−2B−1C0ഉദാഹരണത്തിന്,
അവസാന ഉദാഹരണം അവസാനത്തെ ഒരു സ്ഥാനത്ത് പകരം ഉപയോഗിക്കുന്നതിന് തുല്യമാണ്
ഒരു സൂചികയ്ക്കുള്ളിൽ ഒരു ശ്രേണിയിലേക്ക് ലിപ്യന്തരണം ആയി ഉപയോഗിക്കാവുന്നതാണ്. ഇത് മറ്റൊരു സ്ട്രിംഗിലേക്ക് സ്ട്രിംഗുകളോ സ്ട്രിംഗിൻറെ ഭാഗങ്ങളോ ഇല്ലാതാക്കാനോ ഉപയോഗിക്കാം. ഉദാഹരണത്തിന്,
മുകളിൽ സൂചിപ്പിച്ചതുപോലെ, ഐക്കണുകളുടെ സബ്സ്ക്രിപ്റ്റ് ഘടകങ്ങൾക്കിടയിലുള്ള ഇൻഡൈസുകൾ തമ്മിലാണ്. സ്ട്രിംഗ് നൽകിയിരിക്കുന്നത് ഇപ്രകാരമാണ് s := "ABCDEFG", സൂചികകൾ: 1A2B3C4D5E6F7G8.സ്ലൈസ് s എന്നത് സൂചികകൾ 3 നും 5 നും ഇടയിലുള്ള സ്ട്രിംഗ് ആയ "സിഡി" ആണ്.
ഐക്കൺ ഉപയോക്താവിന് അവരുടെ സ്വന്തം പട്ടികകൾ എളുപ്പത്തിൽ നിർമ്മിക്കാൻ അനുവദിക്കുന്നു:
ഒരു ലിസ്റ്റിലെ ഇനങ്ങൾ ഏതെങ്കിലും തരത്തിലായിരിക്കാം, മറ്റ് ഘടനകൾ ഉൾപ്പെടെ. വലിയ ലിസ്റ്റുകൾ പെട്ടെന്ന് നിർമ്മിക്കുന്നതിന്, ഐക്കൺ list ജനറേറ്റർ ഉൾക്കൊള്ളുന്നു; i := list"പദം" എന്നതിൻറെ 10 കോപ്പികൾ ഉൾക്കൊള്ളുന്ന ഒരു ലിസ്റ്റ് നിർമ്മിക്കുന്നു.
മറ്റ് ഭാഷകളിൽ അറേ പോലുള്ളവ, ഐക്കണുകളിൽ സ്ഥാനം നോക്കി കാണിക്കാൻ അനുവദിക്കുന്നു, ഉദാ: weight := aCat. സ്ട്രിംഗുകളെ പോലെ, ഇൻഡക്സുകൾ ഘടകാംശങ്ങൾക്കിടയിലായിരിക്കും, ശ്രേണി വ്യക്തമാക്കുന്നതി ലൂടെ ഒരു ലിസ്റ്റിൻറെ ഒരു ഭാഗം ലഭിക്കും, ഉദാ. aCat പട്ടിക നൽകുന്നു .സ്ട്രിംഗുകളിൽ നിന്ന് വ്യത്യസ്തമായി, ഒരു ശ്രേണി ഉപയോഗിച്ചുള്ള എൽവാല്യൂ ആകരുത്.
ബാംഗ്-സിൻറാക്സ്, ഉദാ. every write, ഒരു വരിയിൽ ഓരോന്നും നാല് വരികൾ പ്രിൻറ് ചെയ്യും.
ഐക്കണിൽ സ്റ്റാക്ക് പോലുള്ള പ്രവർത്തനങ്ങൾ, push ഒപ്പം pop എന്നിവ സ്റ്റാക്കുകളും ക്യൂകളും അടിസ്ഥാനമാക്കി യുള്ളവയെ അനുവദിക്കുന്നു.
ചിഹ്നങ്ങളും ടേബിളുകളും തുടങ്ങിയ പ്രവർത്തനങ്ങൾ ഐക്കൺ ഉൾപ്പെടുത്തിയിട്ടുണ്ട് :
ഈ കോഡ് ഒരു ടേബിളിനെ സൃഷ്ടിക്കുന്നു. ഇത് അജ്ഞാത കീയുടെ സഹജമായ വിലയായിട്ടാണ് പൂജ്യം ഉപയോഗിയ്ക്കുന്നത്. ഇത് "അവിടെ", "ഇവിടെ" എന്നീ കീകൾ ഉണ്ട്, കൂടാതെ 1, 2 എന്നീ മൂല്യങ്ങളുമായി അതിലേക്ക് രണ്ടു ഇനങ്ങൾ കൂട്ടിച്ചേർക്കുന്നു.
ഐക്കണിൻറെ ശക്തിമത്തായ ഒരു സവിശേഷതയാണ് സ്ട്രിംഗ് സ്കാനിംഗ്. സ്കാൻ സ്ട്രിംഗ് ഓപ്പറേറ്റർ ? നിലവിലെ സ്ട്രിംഗ് സ്കാനിംഗ് പരിതഃസ്ഥിതി സംരക്ഷിക്കുകയും പുതിയ സ്ട്രിംഗ് സ്കാനിംഗ് പരിസ്ഥിതി സൃഷ്ടിക്കുകയും ചെയ്യുന്നു. സ്ട്രിംഗ് സ്കാനിംഗ് പരിസ്ഥിതിയിൽ രണ്ട് കീവേഡ് വേരിയബിളുകൾ അടങ്ങിയിരിക്കുന്നു,&subject ഉം &pos. &subject എന്നത് സ്ട്രിംഗ് സ്കാൻ ചെയ്യുന്നു, &pos കർസർ ആണ്, അല്ലെങ്കിൽ സബജക്ട് സ്ട്രിങ്ങിനുള്ളിലെ നിലവിലെ സ്ഥാനത്തെയാണ്.ഉദാഹരണത്തിന്, 
ഇത് സാക്ഷ്യപ്പെടുത്തുന്നു
സ്ട്രിംഗ് സ്കാൻ ചെയ്യപ്പെടുന്നതിന് വേണ്ടി അന്തർനിർമ്മിതവും ഉപയോക്തൃ നിർവ്വചിത പ്രവർത്തനങ്ങളും ഉപയോഗിക്കാൻ കഴിയും. അന്തർനിർമ്മിതമായ നിരവധി ഫംഗ്ഷനുകൾ സ്ഥിരമായിരിക്കും&subject &pos. ഇനിപ്പറയുന്നവ, ഉദാഹരണമായി, സ്ട്രിങുകൾക്കു ള്ളിൽ "വാക്കുകൾ" എല്ലാ ശൂന്യമായ അതിർത്തികൾ നിർണ്ണയിച്ച് എഴുതുകയും ചെയ്യുന്നു. 
ജനറേറ്ററുകളുടെ ഭാഷയുടെയും സ്ട്രിംഗ് സ്കാനിംഗിൻറെയും സംയോജനം കൂടുതൽ സങ്കീർണ്ണമായ ഉദാഹരണമാണ്.
expr1 & expr2 & expr3 എന്ന ശൈലി അവസാനത്തെ പദപ്രയോഗത്തിൻറെ മൂല്യം നൽകുന്നു.
The definitive work is The Icon Programming Language by Griswold and Griswold, .mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation .cs1-lock-free a{background:urlno-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:urlno-repeat;background-position:right .1em center}.mw-parser-output .citation .cs1-lock-subscription a{background:urlno-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:urlno-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}ISBN 1-57398-001-3.It is out of print but can be downloaded in PDF form.
Icon also has co-expressions, providing non-local exits for program execution. Please see The Icon Programming language and also Shamim Mohamed's article Co-expressions in Icon. 
